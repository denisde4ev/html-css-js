doctype html
html(lang="en" class="h-full")
	head
		meta(charset="UTF-8")
		meta(name="viewport", content="width=device-width, initial-scale=1.0")
		title Monokai Todo App
		script(src="./lib/tw.js")
		style.
			dialog {
				inset-inline-start: 0;
				inset-inline-end: 0;
				margin: auto;
			}
			dialog::backdrop {
				background: rgba(0, 0, 0, 0.5);
			}
	body(class="h-full bg-[#272822] dark:bg-[#1a1b16] text-[#f8f8f2] dark:text-[#f8f8f2] flex items-center justify-center min-h-screen")
		main.container(class="w-full max-w-md mx-auto p-4 rounded-lg shadow-lg bg-[#3e3d32] dark:bg-[#23241f]")
			h1(class="text-2xl font-bold mb-4 text-center text-[#fd971f] dark:text-[#fd971f]") Monokai Todo App
			div.flex.justify-between.items-center.mb-4
				span(class="font-semibold text-lg") Task List
				button#open-modal(
					type="button"
					class="px-3 py-1 rounded bg-[#fd971f] text-white font-medium hover:bg-orange-600 transition-colors"
					aria-label="Add new task"
				) + Add Task
			ul#todo-list(
				class="space-y-2 grid"
				aria-label="Todo list"
				style="display: grid; grid-auto-rows: minmax(0,auto);"
			)
				//- Template for tasks (hidden, to be cloned)
				li.task-template(
					style="display:none"
					class="flex items-start gap-2 p-2 rounded bg-[#272822] dark:bg-[#1a1b16]"
				)
					input(type="checkbox" class="mt-1 accent-[#fd971f]")
					span(class="flex-1 whitespace-pre-line break-words font-mono px-1 rounded cursor-pointer transition-colors outline-none")
					button.edit-btn(
						type="button"
						class="px-2 py-1 rounded bg-[#fd971f] text-white text-xs font-bold ml-1"
						aria-label="Edit task"
					) ✎
					button.up-btn(
						type="button"
						class="px-2 py-1 rounded bg-gray-700 dark:bg-gray-800 text-xs font-bold mr-1 text-white"
						aria-label="Move up"
					) ↑
					button.down-btn(
						type="button"
						class="px-2 py-1 rounded bg-gray-700 dark:bg-gray-800 text-xs font-bold text-white"
						aria-label="Move down"
					) ↓
					button.del-btn(
						type="button"
						class="ml-2 px-2 py-1 rounded bg-red-500 text-white text-xs font-bold hover:bg-red-600"
						aria-label="Delete task"
					) ✕
		dialog#add-modal(
			class="rounded-lg shadow-xl p-0 border-0 bg-[#3e3d32] dark:bg-[#23241f] text-[#f8f8f2] dark:text-[#f8f8f2] w-full max-w-md"
		)
			form#todo-form(
				method="dialog"
				class="flex flex-col gap-3 p-6 pt-4"
				aria-label="Add new task"
			)
				div.flex.justify-between.items-center.mb-2
					h2(class="text-xl font-bold text-[#fd971f] dark:text-[#fd971f]") New Task
					button#close-modal(
						type="button"
						class="text-2xl font-bold text-[#fd971f] dark:text-[#fd971f] hover:text-orange-400 transition-colors px-2 py-0 rounded"
						aria-label="Close modal"
						title="Close"
					) ×
				textarea#new-task(
					class="resize-y min-h-[60px] max-h-40 p-2 rounded border border-[#75715e] dark:border-[#75715e] focus:outline-none focus:ring-2 focus:ring-[#fd971f] bg-[#49483e] dark:bg-[#49483e] text-[#f8f8f2] font-mono"
					placeholder="Type your task here..."
					aria-label="Task description"
					required
				)
				div.flex.justify-end
					button(
						type="submit"
						class="px-3 py-1 rounded bg-[#fd971f] text-white font-medium hover:bg-orange-600 transition-colors"
						aria-label="Add task"
					) Add Task
	script.
		class TodoTask {
			constructor(data, control, li) {
				this.data = data;
				this.control = control;
				this.li = li;
				this.checkbox = li.querySelector('input[type=checkbox]');
				this.span = li.querySelector('span');
				this.editBtn = li.querySelector('.edit-btn');
				this.upBtn = li.querySelector('.up-btn');
				this.downBtn = li.querySelector('.down-btn');
				this.delBtn = li.querySelector('.del-btn');
				this.init();
			}
	
			init() {
				this.li.setAttribute('data-id', this.data.id);
				this.li.style.display = this.data.visible === false ? 'none' : '';
				this.li.style.order = this.data.order;
				this.li.setAttribute('tabindex', '-1'); // for JS focus
				this.checkbox.checked = !!this.data.done;
				this.span.textContent = this.data.text;
				this.updateStyle();
	
				// Remove all listeners first (if reusing)
				this.checkbox.onclick = null;
				this.span.onclick = null;
				this.span.ondblclick = null;
				this.editBtn.onclick = null;
				this.upBtn.onclick = null;
				this.downBtn.onclick = null;
				this.delBtn.onclick = null;
	
				// Checkbox
				this.checkbox.onclick = () => {
					this.control.setDone(this.data.id, !this.data.done);
				};
	
				// Double click to enable and edit (attach before single click)
				this.span.ondblclick = (e) => {
					if (this.data.done) {
						this.control.setDone(this.data.id, false);
						setTimeout(() => this.startEdit(), 0);
					} else {
						this.startEdit();
					}
				};
	
				// Edit button only if not done
				if (!this.data.done) {
					this.editBtn.style.display = '';
					this.editBtn.onclick = () => this.startEdit();
				} else {
					this.editBtn.style.display = 'none';
				}
	
				// Click to toggle done/enable
				this.span.onclick = (e) => {
					if (this.span.isContentEditable) return;
					if (this.data.done) {
						this.control.setDone(this.data.id, false);
					} else {
						this.control.setDone(this.data.id, true);
					}
				};
	
				// Move up/down
				this.upBtn.onclick = () => this.control.move(this.data.id, -1);
				this.downBtn.onclick = () => this.control.move(this.data.id, 1);
	
				// Remove
				this.delBtn.onclick = () => this.control.remove(this.data.id);
	
				// Disabled state for up/down
				this.upBtn.disabled = this.data.order === 0;
				this.downBtn.disabled = this.data.order === this.control.tasks.length - 1;
				this.setDisabledStyle(this.upBtn, this.upBtn.disabled);
				this.setDisabledStyle(this.downBtn, this.downBtn.disabled);
			}
	
			setDisabledStyle(btn, isDisabled) {
				if (isDisabled) {
					btn.classList.add(
						"bg-gray-400",
						"dark:bg-gray-700",
						"text-gray-200",
						"dark:text-gray-500",
						"cursor-not-allowed",
						"opacity-60"
					);
				} else {
					btn.classList.remove(
						"bg-gray-400",
						"dark:bg-gray-700",
						"text-gray-200",
						"dark:text-gray-500",
						"cursor-not-allowed",
						"opacity-60"
					);
				}
			}
	
			updateStyle() {
				if (this.data.done) {
					this.span.classList.add('line-through', 'text-[#75715e]', 'dark:text-[#75715e]');
					this.span.classList.remove('text-[#f8f8f2]', 'dark:text-[#f8f8f2]');
				} else {
					this.span.classList.remove('line-through', 'text-[#75715e]', 'dark:text-[#75715e]');
					this.span.classList.add('text-[#f8f8f2]', 'dark:text-[#f8f8f2]');
				}
			}
	
			startEdit() {
				if (this.span.isContentEditable) return;
				this.span.contentEditable = "true";
				this.span.classList.add('ring-2', 'ring-[#fd971f]', 'bg-[#49483e]');
				this.span.setAttribute('role', 'textbox');
				this.span.setAttribute('tabindex', '0');
				this.span.focus();
				document.execCommand('selectAll', false, null);
				document.getSelection().collapseToEnd();
	
				const finishEdit = (e) => {
					// Only plain Enter (no shift/ctrl/alt/meta) triggers finish
					if (e.type === 'keydown') {
						if (
							e.key !== 'Enter' ||
							e.shiftKey ||
							e.ctrlKey ||
							e.altKey ||
							e.metaKey
						) return;
						e.preventDefault();
					}
					this.span.contentEditable = "false";
					this.span.classList.remove('ring-2', 'ring-[#fd971f]', 'bg-[#49483e]');
					this.span.removeAttribute('role');
					this.span.removeAttribute('tabindex');
					const newText = this.span.textContent;
					if (newText && newText !== this.data.text) {
						this.control.setText(this.data.id, newText);
					} else if (!newText) {
						this.control.remove(this.data.id);
					} else {
						this.updateStyle();
					}
				};
				this.span.addEventListener('blur', finishEdit, { once: true });
				this.span.addEventListener('keydown', finishEdit);
			}
	
			update(data) {
				this.data = data;
				this.init();
			}
	
			hide() {
				this.data.visible = false;
				this.li.style.display = 'none';
			}
	
			show() {
				this.data.visible = true;
				this.li.style.display = '';
			}
		}
	
		class TodoAppControl {
			constructor() {
				this.list = document.getElementById('todo-list');
				this.template = this.list.querySelector('.task-template');
				this.tasks = [];
				this.taskMap = new Map();
				this.load();
				this.render();
				this.setupModal();
				this.setupArrowKeys();
			}
	
			generateId() {
				return '_' + Math.random().toString(36).substr(2, 9);
			}
	
			load() {
				let data = [];
				try {
					data = JSON.parse(localStorage.getItem('tasks')) || [];
				} catch {}
				// Ensure order and id
				data = data.filter(t => t && t.text && typeof t.text === 'string'); // fix: filter out empty/invalid tasks
				data.forEach((t, i) => {
					if (!t.id) t.id = this.generateId();
					t.order = i;
					t.visible = t.visible !== false;
				});
				this.tasks = data;
			}
	
			save() {
				localStorage.setItem('tasks', JSON.stringify(this.tasks));
			}
	
			render() {
				// Ensure enough <li> elements
				while (this.list.children.length - 1 < this.tasks.length) {
					const li = this.template.cloneNode(true);
					li.classList.remove('task-template');
					li.style.display = '';
					this.list.appendChild(li);
				}
				// Hide unused <li>
				for (let i = 0; i < this.list.children.length - 1; ++i) {
					if (i < this.tasks.length) {
						this.list.children[i].style.display = '';
					} else {
						this.list.children[i].style.display = 'none';
					}
				}
				// Map tasks to <li> and create TodoTask instances
				this.taskMap.clear();
				this.tasks.forEach((task, i) => {
					task.order = i;
					const li = this.list.children[i];
					if (!li) return;
					if (!li.todoTask) {
						li.todoTask = new TodoTask(task, this, li);
					} else {
						li.todoTask.update(task);
					}
					this.taskMap.set(task.id, li.todoTask);
					li.style.order = i;
				});
				this.updateMoveButtons();
			}
	
			setDone(id, done) {
				const idx = this.tasks.findIndex(t => t.id === id);
				if (idx === -1) return;
				this.tasks[idx].done = done;
				this.save();
				this.taskMap.get(id).update(this.tasks[idx]);
			}
	
			setText(id, text) {
				const idx = this.tasks.findIndex(t => t.id === id);
				if (idx === -1) return;
				this.tasks[idx].text = text;
				this.save();
				this.taskMap.get(id).update(this.tasks[idx]);
			}
	
			move(id, direction) {
				const idx = this.tasks.findIndex(t => t.id === id);
				const newIdx = idx + direction;
				if (idx === -1 || newIdx < 0 || newIdx >= this.tasks.length) return;
				// Swap orders
				[this.tasks[idx].order, this.tasks[newIdx].order] = [this.tasks[newIdx].order, this.tasks[idx].order];
				// Swap in array
				[this.tasks[idx], this.tasks[newIdx]] = [this.tasks[newIdx], this.tasks[idx]];
				this.save();
				// Update all task orders and buttons
				this.tasks.forEach((t, i) => {
					t.order = i;
					this.taskMap.get(t.id).update(t);
					this.list.children[i].style.order = i;
				});
				this.updateMoveButtons();
			}
	
			remove(id) {
				const idx = this.tasks.findIndex(t => t.id === id);
				if (idx === -1) return;
				this.tasks[idx].visible = false;
				this.save();
				this.taskMap.get(id).hide();
				// Remove from array and re-render to keep order
				this.tasks.splice(idx, 1);
				this.render();
			}
	
			add(text) {
				if (!text || !text.length) return; // fix: do not add empty tasks
				const newTask = {
					id: this.generateId(),
					text,
					done: false,
					order: this.tasks.length,
					visible: true
				};
				this.tasks.push(newTask);
				this.save();
				this.render();
			}
	
			updateMoveButtons() {
				// Called after move or render
				this.tasks.forEach((task, i) => {
					const taskObj = this.taskMap.get(task.id);
					if (taskObj) {
						taskObj.upBtn.disabled = i === 0;
						taskObj.downBtn.disabled = i === this.tasks.length - 1;
						taskObj.setDisabledStyle(taskObj.upBtn, taskObj.upBtn.disabled);
						taskObj.setDisabledStyle(taskObj.downBtn, taskObj.downBtn.disabled);
					}
				});
			}
	
			setupModal() {
				const modal = document.getElementById('add-modal');
				const openModalBtn = document.getElementById('open-modal');
				const closeModalBtn = document.getElementById('close-modal');
				const todoForm = document.getElementById('todo-form');
				const newTaskTextarea = document.getElementById('new-task');
	
				openModalBtn.addEventListener('click', () => {
					modal.showModal();
					setTimeout(() => newTaskTextarea.focus(), 100);
				});
	
				closeModalBtn.addEventListener('click', () => {
					modal.close();
				});
	
				modal.addEventListener('click', (event) => {
					const rect = modal.getBoundingClientRect();
					if (
						event.clientY < rect.top ||
						event.clientY > rect.bottom ||
						event.clientX < rect.left ||
						event.clientX > rect.right
					) {
						modal.close();
					}
				});
	
				todoForm.addEventListener('submit', e => {
					e.preventDefault();
					const text = newTaskTextarea.value;
					if (text && text.length) {
						this.add(text);
						todoForm.reset();
						modal.close();
					}
				});
			}
	
			setupArrowKeys() {
				// Keyboard navigation for up/down arrows
				this.list.addEventListener('keydown', (e) => {
					if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
					// Find focused <li>
					const active = document.activeElement;
					if (!this.list.contains(active)) return;
					let li = active;
					if (li.tagName !== 'LI') li = li.closest('li');
					if (!li) return;
					const items = Array.from(this.list.querySelectorAll('li:not(.task-template):not([style*="display: none"])'));
					const idx = items.indexOf(li);
					if (idx === -1) return;
					let nextIdx = e.key === 'ArrowUp' ? idx - 1 : idx + 1;
					if (nextIdx < 0 || nextIdx >= items.length) return;
					e.preventDefault();
					items[nextIdx].focus();
				});
	
				// Make each <li> focusable
				this.list.addEventListener('focusin', (e) => {
					let li = e.target;
					if (li.tagName !== 'LI') li = li.closest('li');
					if (li) li.setAttribute('tabindex', '-1');
				});
			}
		}
	
		// On DOMContentLoaded
		window.addEventListener('DOMContentLoaded', () => {
			new TodoAppControl();
		});
